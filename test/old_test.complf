

(* we can declare a symbol along with a typing rule associated to it. a symbol comes
   with a name, a list of premises and a type. a premise is given by a name,
   a context, of the form (x1 : A1, .., xk : Ak), and a type.

   a symbol also comes with a mode annotation (+ or -). + indicate that the symbol
   can be used both in infer and check mode, whereas - indicates that the symbol can
   only be used in check mode.

   premises also have mode anotations: a - premise indicates the associated argument
   will be typed in check mode, whereas for + it is typed in infer mode. therefore,
   the term given for a positive premise is expected to be able to synthetize a type *)

(* we start by declaring a (positive) symbol Π, whose arguments are negative *)
symbol+ Π (A : Type)- (B : (x : A) Type)- : Type

(* here we declare λ as negative. because we can recover A and B from it type
   we can have A and B as erased, by puting them around {} *)
symbol- λ {A : Type} {B : (_ : A) Type} (t : (x : A) B(x))- : Π(A, x. B(x))

(* in the following symbol, we omit the polarity annotations of the symbol and the
   fourth premise. the default polarity of a symbol is positive, whereas the
   default polarity of a premise is negative *)
symbol ﹫ {A : Type} {B : (_ : A) Type} (t : Π(A, x. B(x)))+ (u : A) : B(u)

rew ﹫(λ(x. $t(x)), $u) --> $t($u)

(* note that the commands symbol and rew do not do any checking, it is completely
   to the user to make sure that the symbols are well-typed and that rules are confluent
   and preserve typing *)

(* we pose an auxiliary unspecified type *)
symbol T : Type

(* we can make definitions by using the following syntax. the corresponding term
   is checked against the given type (which is thus assumed to be well-formed), and
   then the name is added to the signature, along with an unfolding rewrite rule.
   the following term of type (T -> T) -> T -> T is the church numeral 1 *)
let church1 : Π(Π(T, _. T), _. Π(T, _. T)) := λ(f. λ(x. ﹫(f, x)))

(* when a term is inferable, we can omit the type in the let *)
let church1_id := ﹫(church1, λ(x.x))

(* we can also query the type using the following command *)
type ﹫(church1, λ(x.x))

(* and we can reduce it using eval *)
eval ﹫(church1, λ(x.x))

(* the following raises NotInferable: because we've chosen to not annotate lambdas,
   we cannot infer them *)
(* let ﹫_T := λ(f. λ(x. ﹫(f, x))) *)

(* moreover, we cannot have beta redexes in terms. indeed, the first (non-erased)
   argument of ﹫ is positive, and thus needs to synthetize a type. but because
   λ is a negative constant, it can only be used in check mode. hence, the
   following does not type-check *)
(* let test : Π(T, _. T) := λ(x. ﹫(λ(y.y), x)) *)

(* but if we want we can chose to instead have anotated lambdas *)
symbol Π₂ (A : Type) (B : (x : A) Type) : Type
symbol ﹫₂ {A : Type} {B : (_ : A) Type} (t : Π₂(A, x. B(x)))+ (u : A)- : B(u)

(* by having the A in the syntax, we can now declare the lambda as positive and infer it *)
symbol λ₂ (A : Type) {B : (_ : A) Type} (t : (x : A) B(x))+ : Π₂(A, x. B(x))

rew ﹫₂(λ₂($T, x. $t(x)), $u) --> $t($u)

(* now we can ommit the type in the let *)
let church1' := λ₂(Π₂(T, _. T), f. λ₂(T, x. ﹫₂(f, x)))
type church1'

(* and we can also have beta-redexes in terms *)
type λ₂(T, x. ﹫₂(λ₂(T, y.y), x))

(* let us now define the natural numbers *)
symbol ℕ : Type
symbol 0 : ℕ
symbol S (_ : ℕ) : ℕ

symbol+ ℕ_ind (P : (_ : ℕ) Type)-
              (p0 : P(0))-
              (ps : (n : ℕ, pn : P(n)) P(S(n)))-
              (n : ℕ)-
              (* ------------ *)
              : P(n)
rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), 0) --> $p0
rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), S($n)) -->
    $ps($n, ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), $n))


let ＋ : Π(ℕ, _. Π(ℕ, _. ℕ)) := λ(x. λ(y. ℕ_ind(_. ℕ, x, _ n. S(n), y)))

let 1 := S(0)
let 2 := S(S(0))
let 3 := S(S(S(0)))

(* 3 + 3 *)
let 6 := ﹫(﹫(＋, 3), 3)
eval ﹫(﹫(＋, 3), 3)
eval 6


let × : Π(ℕ, _. Π(ℕ, _. ℕ)) :=
    λ(x. λ(y. ℕ_ind(_. ℕ, 0, _ n. ﹫(﹫(＋, n), x), y)))

(* 3 * 3 *)
let 9 := ﹫(﹫(×, 3), 3)
eval ﹫(﹫(×, 3), 3)
eval 9

let fact : Π(ℕ, _. ℕ) := λ(x. ℕ_ind(_. ℕ, S(0), n m. ﹫(﹫(×, S(n)), m), x))

type ﹫(fact, 3)
eval ﹫(fact, 3)

(* let us now define lists *)
(* note that constructors are defined as negative, which allows us to ommit
   the A in the syntax *)
symbol List (A : Type) : Type
symbol- nil {A : Type} : List(A)
symbol- cons {A : Type} (a : A) (l : List(A)) : List(A)

let nil_nat : List(ℕ) := nil
let 321 : List(ℕ) := cons(3, cons(2, cons(1, nil)))

symbol ind_List {A : Type}
              (l : List(A))+
              (P : (_ : List(A)) Type)
              (l_nil : P(nil))
              (l_cons : (a : A, l : List(A), pl : P(l)) P(cons(a, l)))
              : P(l)

rew ind_List(nil, l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) --> $p_nil
rew ind_List(cons($a, $l), l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) -->
    $p_cons($a, $l, ind_List($l, l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)))


let hd : Π(Type, A. Π(A, _. Π(List(A), _. A)))
    := λ(A. λ(a. λ(l. ind_List(l, _. A, a, x l2 pl. x))))

let tl : Π(Type, A. Π(List(A), _. List(A)))
    := λ(A. λ(l. ind_List(l, _. List(A), nil, x l2 pl. l2)))


eval ﹫(﹫(﹫(hd, ℕ), 0), 321)
eval ﹫(﹫(tl, ℕ), 321)


(* (A : Type) -> (B : Type) -> (A -> B) -> List A -> List B *)
let map : Π(Type, A. Π(Type, B. Π(Π(A, _. B), _. Π(List(A), _. List(B)))))
    := λ(A. λ(B. λ(f. λ(l. ind_List(l, _. List(B), nil, a l2 fl2. cons(﹫(f, a), fl2))))))

let 432 := ﹫(﹫(﹫(﹫(map, ℕ), ℕ), λ(x. S(x))), 321)
eval 432



(* dependent pairs *)

symbol+ Σ (A : Type)- (B : (x : A) Type)- : Type

symbol- mkΣ {A : Type} {B : (_ : A) Type} (t : A) (u : B(t))- : Σ(A, x. B(x))

symbol+ π₁ {A : Type} {B : (_ : A) Type} (t : Σ(A, x. B(x)))+ : A

symbol+ π₂ {A : Type} {B : (_ : A) Type} (t : Σ(A, x. B(x)))+ : B(π₁(t))

rew π₁(mkΣ($t, $u)) --> $t

rew π₂(mkΣ($t, $u)) --> $u


let pair : Σ(ℕ, _. ℕ) := mkΣ(6, 9)
type pair

eval π₂(pair)
type π₂(pair)
