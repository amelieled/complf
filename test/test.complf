(* judgment forms *)

symbol Ty : *

symbol Tm (A : Ty) : *

(* we can declare a symbol along with a typing rule associated to it. a symbol comes
   with a name, a list of premises and a type. a premise is given by a name,
   a context, of the form (x1 : A1, .., xk : Ak), and a type.

   a symbol also comes with a mode annotation (+ or -). + indicate that the symbol
   can be used both in infer and check mode, whereas - indicates that the symbol can
   only be used in check mode.

   premises also have mode anotations: a - premise indicates the associated argument
   will be typed in check mode, whereas for + it is typed in infer mode. therefore,
   the term given for a positive premise is expected to be able to synthetize a type *)

(* we start by declaring a (positive) symbol Π, whose arguments are negative *)
symbol+ Π (A : Ty)- (B : (x : Tm A) Ty)- : Ty

(* here we declare λ as negative. because we can recover A and B from it type
   we can have A and B as erased, by puting them around {} *)
symbol- λ {A : Ty} {B : (_ : Tm A) Ty} (t : (x : Tm A) Tm B(x))- : Tm Π(A, x. B(x))

(* in the following symbol, we omit the polarity annotations of the symbol and the
   fourth premise. the default polarity of a symbol is positive, whereas the
   default polarity of a premise is negative *)
symbol ﹫ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Π(A, x. B(x)))+ (u : Tm A) : Tm B(u)

rew ﹫(λ(x. $t(x)), $u) --> $t($u)

(* note that the commands symbol and rew do not do any checking, it is completely
   to the user to make sure that the symbols are well-typed and that rules are confluent
   and preserve typing *)

(* we pose an auxiliary unspecified type *)
symbol T : Ty

(* we can make definitions by using the following syntax. the corresponding term
   is checked against the given type (which is thus assumed to be well-formed), and
   then the name is added to the signature, along with an unfolding rewrite rule.
   the following term of type (T -> T) -> T -> T is the church numeral 1 *)
let church1 : Tm Π(Π(T, _. T), _. Π(T, _. T)) := λ(f. λ(x. ﹫(f, x)))

(* when a term is inferable, we can omit the type in the let *)
let church1_id := ﹫(church1, λ(x.x))

(* we can also query the type using the following command *)
type ﹫(church1, λ(x.x))

(* and we can reduce it using eval *)
eval ﹫(church1, λ(x.x))

(* the following raises NotInferable: because we've chosen to not annotate lambdas,
   we cannot infer them *)
(* let ﹫_T := λ(f. λ(x. ﹫(f, x))) *)

(* moreover, we cannot have beta redexes in terms. indeed, the first (non-erased)
   argument of ﹫ is positive, and thus needs to synthetize a type. but because
   λ is a negative constant, it can only be used in check mode. hence, the
   following does not type-check *)
(* let test : Tm Π(T, _. T) := λ(x. ﹫(λ(y.y), x)) *)

(* but if we want we can chose to instead have anotated lambdas *)
symbol Π₂ (A : Ty) (B : (x : Tm A) Ty) : Ty
symbol ﹫₂ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Π₂(A, x. B(x)))+ (u : Tm A)- : Tm B(u)

(* by having the A in the syntax, we can now declare the lambda as positive and infer it *)
symbol λ₂ (A : Ty) {B : (_ : Tm A) Ty} (t : (x : Tm A) Tm B(x))+ : Tm Π₂(A, x. B(x))

rew ﹫₂(λ₂($T, x. $t(x)), $u) --> $t($u)

(* now we can ommit the type in the let *)
let church1' := λ₂(Π₂(T, _. T), f. λ₂(T, x. ﹫₂(f, x)))
type church1'

(* and we can also have beta-redexes in terms *)
type λ₂(T, x. ﹫₂(λ₂(T, y.y), x))

(* let us now define the natural numbers *)
symbol ℕ : Ty
symbol 0 : Tm ℕ
symbol S (_ : Tm ℕ) : Tm ℕ

symbol+ ℕ_ind (P : (_ : Tm ℕ) Ty)-
              (p0 : Tm P(0))-
              (ps : (n : Tm ℕ, pn : Tm P(n)) Tm P(S(n)))-
              (n : Tm ℕ)-
              (* ------------ *)
              : Tm P(n)
rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), 0) --> $p0
rew ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), S($n)) -->
    $ps($n, ℕ_ind(x. $P(x), $p0, n pn. $ps(n, pn), $n))


let ＋ : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) := λ(x. λ(y. ℕ_ind(_. ℕ, x, _ n. S(n), y)))

let 1 := S(0)
let 2 := S(S(0))
let 3 := S(S(S(0)))

(* 3 + 3 *)
let 6 := ﹫(﹫(＋, 3), 3)
eval ﹫(﹫(＋, 3), 3)
eval 6


let × : Tm Π(ℕ, _. Π(ℕ, _. ℕ)) :=
    λ(x. λ(y. ℕ_ind(_. ℕ, 0, _ n. ﹫(﹫(＋, n), x), y)))

(* 3 * 3 *)
let 9 := ﹫(﹫(×, 3), 3)
eval ﹫(﹫(×, 3), 3)
eval 9

let fact : Tm Π(ℕ, _. ℕ) := λ(x. ℕ_ind(_. ℕ, S(0), n m. ﹫(﹫(×, S(n)), m), x))

type ﹫(fact, 3)
eval ﹫(fact, 3)

(* a test of nonlinear matching *)
symbol eqℕ (_ : Tm ℕ) (_ : Tm ℕ) : Tm ℕ
rew eqℕ($t, $t) --> $t

eval eqℕ(0, 1)
eval eqℕ(﹫(fact, 3), 6)

(* let us now define lists *)
(* note that constructors are defined as negative, which allows us to ommit
   the A in the syntax *)
symbol List (A : Ty) : Ty
symbol- nil {A : Ty} : Tm List(A)
symbol- cons {A : Ty} (a : Tm A) (l : Tm List(A)) : Tm List(A)

let nil_nat : Tm List(ℕ) := nil
let 321 : Tm List(ℕ) := cons(3, cons(2, cons(1, nil)))

symbol ind_List {A : Ty}
              (l : Tm List(A))+
              (P : (_ : Tm List(A)) Ty)
              (l_nil : Tm P(nil))
              (l_cons : (a : Tm A, l : Tm List(A), pl : Tm P(l)) Tm P(cons(a, l)))
              : Tm P(l)

rew ind_List(nil, l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) --> $p_nil
rew ind_List(cons($a, $l), l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)) -->
    $p_cons($a, $l, ind_List($l, l. $P(l), $p_nil, a l pl. $p_cons(a, l, pl)))


let hdℕ : Tm Π(List(ℕ), _. ℕ)
    := λ(l. ind_List(l, _. ℕ, 0, x l2 pl. x))

let tlℕ : Tm Π(List(ℕ), _. List(ℕ))
    := λ(l. ind_List(l, _. List(ℕ), nil, x l2 pl. l2))

eval ﹫(hdℕ, 321)
eval ﹫(hdℕ, nil)
eval ﹫(tlℕ, 321)


(* dependent pairs *)

symbol+ Σ (A : Ty)- (B : (x : Tm A) Ty)- : Ty

symbol- mkΣ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm A) (u : Tm B(t))- : Tm Σ(A, x. B(x))

symbol+ π₁ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm A

symbol+ π₂ {A : Ty} {B : (_ : Tm A) Ty} (t : Tm Σ(A, x. B(x)))+ : Tm B(π₁(t))

rew π₁(mkΣ($t, $u)) --> $t

rew π₂(mkΣ($t, $u)) --> $u


let pair : Tm Σ(ℕ, _. ℕ) := mkΣ(6, 9)
type pair

eval π₂(pair)
type π₂(pair)

(* equality *)

symbol Eq (A : Ty) (t : Tm A) (u : Tm A) : Ty
symbol- refl {A : Ty} {t : Tm A} : Tm Eq(A, t, t)

let pair2 : Tm Σ(ℕ, x. Eq(ℕ, x, x)) := mkΣ(6, refl)
let pair3 : Tm Σ(ℕ, x. Eq(ℕ, ﹫(fact, 3), x)) := mkΣ(6, refl)

symbol J {A : Ty} {a : Tm A} {b : Tm A} (t : Tm Eq(A, a, b))+
       (P : (x : Tm A, y : Tm Eq(A, a, x)) Ty) (prefl : Tm P(a, refl)) : Tm P(b, t)

rew J(refl, x y. $P(x, y), $prefl) --> $prefl

(* universe *)

symbol U : Ty
symbol El (A : Tm U) : Ty

symbol nat : Tm U
rew El(nat) --> ℕ

symbol π (a : Tm U) (b : (_ : Tm El(a)) Tm U) : Tm U
rew El(π($a, x.$b(x))) --> Π(El($a), x. El($b(x)))

(* type in type *)
symbol u : Tm U
rew El(u) --> U

eval El(π(nat, _. u))



let sym : Tm Π(U, a. Π(El(a), x. Π(El(a), y. Π(Eq(El(a), x, y), _. Eq(El(a), y, x)))))
    :=  λ(a. λ(x. λ(y. λ(p. J(p, z q. Eq(El(a), z, x), refl)))))
type ﹫(sym, nat)
